package {{package}};

{{#imports}}import {{.}};
{{/imports}}

import javax.ws.rs.*;
import javax.ws.rs.core.CacheControl;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.ResponseBuilder;
import javax.enterprise.context.RequestScoped;
import javax.inject.Inject;

import io.swagger.annotations.*;
import io.swagger.jaxrs.PATCH;
import java.io.InputStream;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.apache.cxf.jaxrs.ext.multipart.Attachment;
import org.apache.cxf.jaxrs.ext.multipart.Multipart;
import com.cactuslab.jaxrs.auth.Authenticated;

import java.util.Map;
import java.util.List;

@Path("{{{path}}}")
// @RequestScoped // This annotation is commented out, which makes the service a Singleton. There seems to be a bug that causes the securityContext to be lost if the service is RequestScoped

@Api(description = "the {{{name}}} API")
{{#if consumes}}@Consumes({ {{#consumes}}"{{{.}}}"{{#unless @last}}, {{/unless}}{{/consumes}} }){{/if}}
{{#if produces}}@Produces({ {{#produces}}"{{{.}}}"{{#unless @last}}, {{/unless}}{{/produces}} }){{/if}}
{{>generatedAnnotation}}

@SuppressWarnings("all")
public class {{className name}}Api  {

  @Inject {{className name}}ApiService delegate;

  @SuppressWarnings("all")
  private static final Log log = LogFactory.getLog({{className name}}Api.class);

{{#operations}}
{{^vendorExtensions.x-implementation-provided}}

{{>nestedModels}}

    @{{httpMethod}}{{#if authMethods}} @Authenticated{{/if}}{{#isDeprecated}} @Deprecated{{/isDeprecated}}
    {{#if path}}@Path("{{{path}}}"){{/if}}
    {{#if consumes}}@Consumes({ {{#consumes}}"{{{mediaType}}}"{{#hasMore}}, {{/hasMore}}{{/consumes}} }){{/if}}
    {{#if produces}}@Produces({ {{#produces}}"{{{mediaType}}}"{{#hasMore}}, {{/hasMore}}{{/produces}} }){{/if}}
    @ApiOperation(value = "{{{summary}}}", notes = "{{{notes}}}", response = {{#if returnNativeType}}{{{returnNativeType}}}{{else}}Void{{/if}}.class{{#returnContainer}}, responseContainer = "{{{returnContainer}}}"{{/returnContainer}}{{#if authMethods}}, authorizations = {
        {{#authMethods}}@Authorization(value = "{{name}}"{{#isOAuth}}, scopes = {
            {{#scopes}}@AuthorizationScope(scope = "{{scope}}", description = "{{description}}"){{#unless @last}},
            {{/unless}}{{/scopes}}
        }{{/isOAuth}}){{#unless @last}},
        {{/unless}}{{/authMethods}}
    }{{/if}}, tags={ {{#tags}}"{{.}}"{{#unless @last}}, {{/unless}}{{/tags}} })
    @ApiResponses(value = { {{#responses}}
        @ApiResponse(code = {{{code}}}, message = "{{{description}}}", response = {{#if nativeType}}{{{nativeType}}}{{else}}Void{{/if}}.class{{#containerType}}, responseContainer = "{{{containerType}}}"{{/containerType}}){{#hasMore}},{{/hasMore}}{{/responses}}
    })
    public Response {{name}}({{#allParams}}{{>queryParams}}{{>pathParams}}{{>headerParams}}{{>bodyParams}}{{>formParams}}{{#hasMore}}, {{/hasMore}}{{/allParams}}) {
    	{{#responses}}{{#isDefault}}final ResponseBuilder response = Response.status({{code}}).cacheControl(CacheControl.valueOf("{{{vendorExtensions.x-cache-control}}}{{^vendorExtensions.x-cache-control}}no-cache, no-store, must-revalidate, private{{/vendorExtensions.x-cache-control}}"));{{/isDefault}}{{/responses}}
    	{{#isDeprecated}}log.error("Deprecated API called: {{name}}");{{/isDeprecated}}
    	try {
    		{{#@root.useBeanValidation}}{{#allParams}}{{#if vendorExtensions.x-validation}}
    		javax.validation.ValidatorFactory factory = javax.validation.Validation.buildDefaultValidatorFactory();
			javax.validation.Validator validator = factory.getValidator();
			java.util.Set<javax.validation.ConstraintViolation<{{{nativeType}}}>> validations = validator.validate({{identifier name}});
			if (!validations.isEmpty()) {
				throw new {{{className @root/name}}}ApiService.{{{className ../name}}}400Exception(validations);
			}
			
    		{{/if}}{{/allParams}}{{/@root.useBeanValidation}}{{#defaultResponse}}
    		{{#if nativeType}}{{nativeType}} entity = {{/if}}delegate.{{identifier ../name}}({{#../allParams}}{{#if isFile}}{{identifier name}}InputStream, {{identifier name}}Detail{{else}}{{identifier name}}{{/if}}, {{/../allParams}}response);
    		{{#if nativeType}}
    		response.entity(entity);
    		{{/if}}
    		return response.build();
    		{{/defaultResponse}}
        {{#responses}}{{^isDefault}}
        } catch ({{{className @root/name}}}ApiService.{{{className ../name}}}{{{code}}}Exception e) {
        	response.status({{code}});
        	{{^vendorExtensions.x-java-is-response-void}}
        	response.entity(e.getEntity());
        	{{/vendorExtensions.x-java-is-response-void}}
        	return response.build();
        {{/isDefault}}{{/responses}}
        } finally {
        
        }
    }

{{/vendorExtensions.x-implementation-provided}}
{{/operations}}
}
